# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:23:45+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from pydantic import conint

from models import (
    AnalysesUsernameProjectSlugAnalysisSlugCrawlStatisticsUrlsListTypeGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugFeaturesGanalyticsOrphanUrlsMediumSourceGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugFeaturesSitemapsSamplesOutOfConfigGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugFeaturesSitemapsSamplesSitemapOnlyGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugFeaturesTopDomainsDomainsGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugFeaturesTopDomainsSubdomainsGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugUrlsAggsPostResponse,
    AnalysesUsernameProjectSlugAnalysisSlugUrlsExportGetResponse,
    AnalysesUsernameProjectSlugAnalysisSlugUrlsPostResponse,
    AnalysesUsernameProjectSlugGetResponse,
    AnalysisDetail,
    Area,
    Area8,
    Area10,
    CrawlDatamodel,
    CrawlStatistics,
    CrawlStatisticsTime,
    CsvExportStatus,
    Default,
    DefaultPayload,
    Fields,
    Frequency,
    LinksPercentiles,
    ListType,
    Medium,
    PageRankLost,
    ProjectSavedFilter,
    ProjectsUsernameGetResponse,
    ProjectsUsernameProjectSlugFiltersGetResponse,
    SitemapsReport,
    Source,
    UrlDetail,
    URLRewritingRulesSerializer,
    UrlsAggsQueries,
    UrlsAggsQuery,
    UrlsQuery,
)

app = MCPProxy(
    description='Botify Saas API',
    title='Botify API',
    version='1.0.0',
    servers=[{'url': 'https://api.botify.com/v1'}],
)


@app.get(
    '/analyses/{username}/{project_slug}',
    description=""" List all analyses for a project """,
    tags=['project_analysis_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_project_analyses(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
):
    """
    List all analyses for a project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}',
    description=""" Get an Analysis detail """,
    tags=['project_analysis_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_analysis_summary(
    username: str, project_slug: str = ..., analysis_slug: str = ...
):
    """
    Get an Analysis detail
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics',
    description=""" Return global statistics for an analysis """,
    tags=['project_analysis_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_crawl_statistics(
    username: str, project_slug: str = ..., analysis_slug: str = ...
):
    """
    Return global statistics for an analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/time',
    description=""" Return crawl statistics grouped by time frequency (1 min, 5 mins or 60 min) for an analysis """,
    tags=['project_analysis_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_crawl_statistics_by_frequency(
    limit: Optional[int] = None,
    frequency: Frequency = ...,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    Return crawl statistics grouped by time frequency (1 min, 5 mins or 60 min)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/crawl_statistics/urls/{list_type}',
    description=""" Return a list of 1000 latest URLs crawled (all crawled URLs or only URLS with HTTP errors) """,
    tags=['project_analysis_management', 'url_data_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_crawl_statistics_urls(
    username: str,
    project_slug: str = ...,
    analysis_slug: str = ...,
    list_type: ListType = ...,
):
    """
    Return a list of 1000 latest URLs crawled (all crawled URLs or only URLS with HTTP errors)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/ganalytics/orphan_urls/{medium}/{source}',
    description=""" List of Orphan URLs. URLs which generated visits from the selected source according to Google Analytics data, but were not crawled with by the Botify crawler (either because no links to them were found on the website, or because the crawler was not allowed to follow these links according to the project settings).   For a search engine (medium: origanic; sources: all, aol, ask, baidu, bing, google, naver, yahoo, yandex) or a social network (medium: social; sources: all, facebook, google+, linkedin, pinterest, reddit, tumblr, twitter) """,
    tags=['url_data_operations', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_ganalytics_orphan_u_r_ls(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
    medium: Medium = ...,
    source: Source = ...,
):
    """
    List of Orphan URLs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/links/percentiles',
    description=""" Get inlinks percentiles """,
    tags=['project_analysis_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_links_percentiles(
    username: str, project_slug: str = ..., analysis_slug: str = ...
):
    """
    Get inlinks percentiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/pagerank/lost',
    description=""" Lost pagerank """,
    tags=['project_analysis_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_page_rank_lost(
    username: str, project_slug: str = ..., analysis_slug: str = ...
):
    """
    Lost pagerank
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/report',
    description=""" Get global information of the sitemaps found (sitemaps indexes, invalid sitemaps urls, etc.) """,
    tags=['project_analysis_management', 'sitemap_report_generation'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sitemaps_report(
    username: str, project_slug: str = ..., analysis_slug: str = ...
):
    """
    Get global information of the sitemaps found (sitemaps indexes, invalid sitemaps urls, etc
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples/out_of_config',
    description=""" Sample list of URLs which were found in your sitemaps but outside of the crawl perimeter defined for the project, for instance domain/subdomain or protocol (HTTP/HTTPS) not allowed in the crawl settings. """,
    tags=[
        'sitemap_report_generation',
        'url_data_operations',
        'user_associated_projects',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sitemaps_samples_out_of_config(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    Sample list of URLs which were found in your sitemaps but outside of the
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/sitemaps/samples/sitemap_only',
    description=""" Sample list of URLs which were found in your sitemaps, within the project allowed scope (allowed domains/subdomains/protocols), but not found by the Botify crawler. """,
    tags=[
        'sitemap_report_generation',
        'url_data_operations',
        'user_associated_projects',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_sitemaps_samples_sitemaps_only(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    Sample list of URLs which were found in your sitemaps, within the project
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains/domains',
    description=""" Top domains """,
    tags=[
        'project_analysis_management',
        'url_data_operations',
        'user_associated_projects',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_links_top_domains(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    Top domains
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/features/top_domains/subdomains',
    description=""" Top subddomains """,
    tags=['project_analysis_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_links_top_subdomains(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    Top subddomains
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls',
    description=""" Executes a query and returns a paginated response """,
    tags=[
        'project_analysis_management',
        'url_data_operations',
        'user_associated_projects',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_urls(
    area: Optional[Area] = 'current',
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
    body: UrlsQuery = None,
):
    """
    Executes a query and returns a paginated response
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/aggs',
    description=""" Query aggregator. It accepts multiple queries """,
    tags=[
        'project_analysis_management',
        'url_data_operations',
        'user_associated_projects',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_urls_aggs(
    area: Optional[Area] = 'current',
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
    body: UrlsAggsQueries = None,
):
    """
    Query aggregator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/datamodel',
    description=""" Gets an Analysis datamodel """,
    tags=['project_analysis_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_urls_datamodel(
    area: Optional[Area] = 'current',
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    Gets an Analysis datamodel
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/export',
    description=""" A list of the CSV Exports requests and their current status """,
    tags=['url_export_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_urls_exports(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
):
    """
    A list of the CSV Exports requests and their current status
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/export',
    description=""" Creates a new UrlExport object and starts a task that will export the results into a csv. Returns the model id that manages the task """,
    tags=['url_export_management', 'url_data_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_urls_export(
    area: Optional[Area] = 'current',
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
    body: UrlsQuery = None,
):
    """
    Creates a new UrlExport object and starts a task that will export the results into a csv
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/export/{url_export_id}',
    description=""" Checks the status of an CSVUrlExportJob object. Returns json object with the status. """,
    tags=['url_export_management', 'url_data_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_urls_export_status(
    username: str,
    project_slug: str = ...,
    analysis_slug: str = ...,
    url_export_id: str = ...,
):
    """
    Checks the status of an CSVUrlExportJob object
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/suggested_filters',
    description=""" Return most frequent segments (= suggested patterns in the previous version) for a Botify Query. """,
    tags=['project_analysis_management', 'url_data_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_urls_suggested_filters(
    area: Optional[Area8] = 'current',
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
    body: UrlsAggsQuery = None,
):
    """
    Return most frequent segments (= suggested patterns in the previous version)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/analyses/{username}/{project_slug}/{analysis_slug}/urls/{url}',
    description=""" Gets the detail of an URL for an analysis """,
    tags=['project_analysis_management', 'url_data_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_url_detail(
    fields: Optional[Fields] = None,
    username: str = ...,
    project_slug: str = ...,
    analysis_slug: str = ...,
    url: str = ...,
):
    """
    Gets the detail of an URL for an analysis
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{username}',
    description=""" List all active projects for the user """,
    tags=['user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_user_projects(
    page: Optional[int] = None, size: Optional[int] = None, username: str = ...
):
    """
    List all active projects for the user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{username}/{project_slug}/features/url_rewriting/rules_validator',
    description=""" Match and replace parts of a URL based on rules passed in POST data. """,
    tags=['url_data_operations', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def test_url_rewriting_rules(username: str, project_slug: str = ...):
    """
    Match and replace parts of a URL based on rules passed in POST data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{username}/{project_slug}/filters',
    description=""" List all the project's saved filters (each filter's name, ID and filter value) """,
    tags=['saved_filter_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_saved_filters(
    page: Optional[int] = None,
    size: Optional[int] = None,
    username: str = ...,
    project_slug: str = ...,
):
    """
    List all the project's saved filters (each filter's name, ID and filter value)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/projects/{username}/{project_slug}/filters/{identifier}',
    description=""" Retrieves a specific saved filter's name, ID and filter value """,
    tags=['saved_filter_management', 'user_associated_projects'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_saved_filter(username: str, project_slug: str = ..., identifier: str = ...):
    """
    Retrieves a specific saved filter's name, ID and filter value
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/projects/{username}/{project_slug}/urls/aggs',
    description=""" Project Query aggregator. It accepts multiple queries that will be executed on all completed analyses in the project """,
    tags=[
        'project_analysis_management',
        'url_data_operations',
        'user_associated_projects',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_project_urls_aggs(
    area: Optional[Area10] = 'current',
    last_analysis_slug: Optional[str] = None,
    nb_analyses: Optional[conint(ge=1, le=20)] = 20,
    username: str = ...,
    project_slug: str = ...,
    body: UrlsAggsQueries = None,
):
    """
    Project Query aggregator
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
